"""
Module I: Topology Architect
Responsible for converting chemical information (SMILES) into physical topology (LAMMPS Data File).
"""

import sys
from pathlib import Path
from rdkit import Chem
from rdkit.Chem import AllChem
import numpy as np

def generate_topology(smiles: str, output_path: Path, padding: float = 10.0):
    """
    Generates a LAMMPS data file from a SMILES string using a generic force field estimation.

    Args:
        smiles (str): The SMILES string of the polymer/molecule.
        output_path (Path): Path to save the 'polymer.data' file.
        padding (float): Padding in Angstroms to add around the molecule for the simulation box.
    """
    print(f"[*] Generating topology for SMILES: {smiles}")
    
    # 1. RDKit Molecule Generation
    mol = Chem.MolFromSmiles(smiles)
    if not mol:
        print("Error: RDKit failed to parse SMILES string.")
        sys.exit(1)
    
    mol = Chem.AddHs(mol)
    
    # 2. 3D Embedding
    params = AllChem.ETKDG()
    params.randomSeed = 42
    status = AllChem.EmbedMolecule(mol, params)
    
    if status != 0:
        print("Error: RDKit failed to embed molecule in 3D.")
        # Try one more time with random coords
        status = AllChem.EmbedMolecule(mol, useRandomCoords=True)
        if status != 0:
            print("Critical Error: Could not generate 3D coordinates.")
            sys.exit(1)

    # Optimize geometry slightly to prevent severe clashes
    try:
        AllChem.UFFOptimizeMolecule(mol)
    except Exception as e:
        print(f"Warning: UFF Optimization failed ({e}), proceeding with raw coords.")

    conf = mol.GetConformer()
    
    # 3. Analyze Topology for LAMMPS
    atoms = mol.GetAtoms()
    bonds = mol.GetBonds()
    
    # Map elements to LAMMPS types
    # Simple mapping: C=1, H=2, O=3, N=4, others sequential
    element_map = {'C': 1, 'H': 2, 'O': 3, 'N': 4}
    next_type = 5
    
    atom_types_map = {} # atomic_num -> lammps_type
    mass_map = {}       # lammps_type -> mass
    
    # Pre-scan atoms to build maps
    for atom in atoms:
        symbol = atom.GetSymbol()
        mass = atom.GetMass()
        if symbol in element_map:
            l_type = element_map[symbol]
        else:
            if symbol not in [k for k,v in element_map.items() if v >= 5]:
                element_map[symbol] = next_type
                next_type += 1
            l_type = element_map[symbol]
        
        atom_types_map[atom.GetAtomicNum()] = l_type
        mass_map[l_type] = mass

    num_atom_types = len(mass_map)
    num_bond_types = 1 # Generic bond
    
    # Calculate Box Bounds
    positions = conf.GetPositions()
    min_xyz = positions.min(axis=0) - padding
    max_xyz = positions.max(axis=0) + padding
    
    # 4. Write LAMMPS Data File
    with open(output_path, 'w') as f:
        f.write(f"LAMMPS data file generated by Proteus for {smiles}\n\n")
        
        f.write(f"{mol.GetNumAtoms()} atoms\n")
        f.write(f"{mol.GetNumBonds()} bonds\n")
        f.write("0 angles\n0 dihedrals\n0 impropers\n\n")
        
        f.write(f"{num_atom_types} atom types\n")
        f.write(f"{num_bond_types} bond types\n\n")
        
        f.write(f"{min_xyz[0]:.4f} {max_xyz[0]:.4f} xlo xhi\n")
        f.write(f"{min_xyz[1]:.4f} {max_xyz[1]:.4f} ylo yhi\n")
        f.write(f"{min_xyz[2]:.4f} {max_xyz[2]:.4f} zlo zhi\n\n")
        
        f.write("Masses\n\n")
        for l_type, mass in sorted(mass_map.items()):
            f.write(f"{l_type} {mass:.4f} # {list(element_map.keys())[list(element_map.values()).index(l_type)]}\n")
        f.write("\n")
        
        f.write("Atoms # full\n\n")
        # atom-ID molecule-ID atom-type q x y z
        for i, atom in enumerate(atoms):
            idx = i + 1
            l_type = atom_types_map[atom.GetAtomicNum()]
            pos = positions[i]
            # Generic charge 0.0 for now as requested by "generic writer" simplification
            # or partial charges could be calculated via RDKit Gasteiger
            AllChem.ComputeGasteigerCharges(mol)
            q = float(atom.GetProp('_GasteigerCharge')) if atom.HasProp('_GasteigerCharge') else 0.0
            
            f.write(f"{idx} 1 {l_type} {q:.5f} {pos[0]:.5f} {pos[1]:.5f} {pos[2]:.5f}\n")
        f.write("\n")
        
        f.write("Bonds\n\n")
        # ID type atom1 atom2
        for i, bond in enumerate(bonds):
            idx = i + 1
            a1 = bond.GetBeginAtomIdx() + 1
            a2 = bond.GetEndAtomIdx() + 1
            f.write(f"{idx} 1 {a1} {a2}\n")
            
    print(f"[*] Topology written to {output_path}")
    return element_map, mass_map

if __name__ == "__main__":
    # Test block
    generate_topology("CCO", Path("test.data"))
