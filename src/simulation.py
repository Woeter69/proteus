"""
Module II & III: Simulation Engine
Generates the LAMMPS input script and executes the simulation.
"""

import subprocess
import sys
import os
from pathlib import Path

# Standard OPLS-AA Non-bonded parameters (kcal/mol, Angstroms)
# 1:C, 2:H, 3:O, 4:N, 5:S
CHONS_DEFAULTS = {
    1: (0.066, 3.50),  # Carbon (Alkane)
    2: (0.030, 2.50),  # Hydrogen
    3: (0.170, 3.12),  # Oxygen (Carbonyl)
    4: (0.170, 3.25),  # Nitrogen
    5: (0.250, 3.55)   # Sulfur
}

def generate_input_file(
    data_file: Path,
    input_file: Path,
    output_dump: Path,
    steps: int = 10000,
    temp: float = 300.0,
    damp: float = 20.0,
    epsilon: float = None, # None means use CHONS defaults
    sigma: float = None,   # None means use CHONS defaults
    timestep: float = 1.0,
    bond_params: dict = None,
    angle_params: dict = None,
    dihedral_params: dict = None
):
    """
    Writes the simulation.in file for LAMMPS with CHONS support and dynamic bonds/angles/dihedrals.
    """
    
    pair_params = {}
    for t in range(1, 6):
        # Use user override if provided, else use real-world default
        final_eps = epsilon if epsilon is not None else CHONS_DEFAULTS[t][0]
        final_sig = sigma if sigma is not None else CHONS_DEFAULTS[t][1]
        pair_params[t] = (final_eps, final_sig)
    
    # Calculate cutoff based on the largest sigma in the system
    max_sigma = max([p[1] for p in pair_params.values()])
    lj_cutoff = max(10.0, 3.0 * max_sigma)

    # Dynamic output frequency: Aim for ~250 data points/frames
    out_freq = max(10, steps // 250)

    lines = [
        "# LAMMPS Input file generated by Proteus (CHONS Forcefield)",
        "",
        "units real",
        "atom_style full",
        "boundary p p p",
        "",
        f"read_data {data_file.absolute()}",
        "",
        "# Force Field",
        f"pair_style lj/cut {lj_cutoff:.2f}",
        "pair_modify mix arithmetic"
    ]

    # Write pair coefficients
    for t, (eps, sig) in pair_params.items():
        lines.append(f"pair_coeff {t} {t} {eps} {sig}")

    # Dynamic Bonds
    lines.extend(["", "bond_style harmonic"])
    if bond_params:
        for b_type, (k, r0) in bond_params.items():
            lines.append(f"bond_coeff {b_type} {k} {r0}")
    else:
        lines.append("bond_coeff 1 300.0 1.54")

    # Dynamic Angles
    lines.extend(["", "angle_style harmonic"])
    if angle_params:
        for a_type, (k, theta0) in angle_params.items():
            lines.append(f"angle_coeff {a_type} {k} {theta0}")
    else:
        lines.append("angle_coeff 1 60.0 109.5")

    # Dynamic Dihedrals
    if dihedral_params:
        lines.extend(["", "dihedral_style harmonic"])
        for d_type, (k, d, n) in dihedral_params.items():
            lines.append(f"dihedral_coeff {d_type} {k} {d} {n}")

    lines.extend([
        "",
        "neighbor 2.0 bin",
        "neigh_modify delay 0 every 10 check yes",
        "",
        "# 1-4 interactions are typically scaled in molecular force fields",
        "special_bonds lj 0.0 0.0 0.5",
        "",
        "# Group definitions",
        "group all_atoms type 1 2 3 4 5",
        "",
        "# Simulation Protocol",
        "minimize 1.0e-4 1.0e-6 1000 10000",
        "reset_timestep 0",
        "",
        f"timestep {timestep}",
        "",
        "# 2. Equilibration / Dynamics",
        f"fix 1 all langevin {temp} {temp} {damp} {os.getpid() % 100000}", # Random-ish seed
        "fix 2 all nve",
        "",
        "# Output",
        f"dump 1 all custom {out_freq} {output_dump.absolute()} id mol type x y z",
        "compute rg all gyration",
        "thermo_style custom step c_rg temp epair",
        f"thermo {out_freq}",
        "",
        "# Run",
        f"run {steps}"
    ])

    with open(input_file, 'w') as f:
        f.write("\n".join(lines) + "\n")
    
    print(f"[*] Input file written to {input_file}")

def run_simulation(input_file: Path, log_file: Path, gpus: int = 1):
    """
    Executes LAMMPS simulation with streaming output and optional GPU support.
    """
    print(f"[*] Starting LAMMPS simulation: {input_file.name}")
    
    local_lmp = Path(__file__).parent.parent / "external" / "lammps" / "build" / "lmp"
    
    if local_lmp.exists():
        print(f"[*] Using local GPU-enabled LAMMPS binary: {local_lmp}")
        cmd = [str(local_lmp), "-sf", "gpu", "-pk", "gpu", str(gpus), "-in", str(input_file), "-log", str(log_file)]
    else:
        print("[!] Local GPU LAMMPS not found, falling back to system 'lmp' (CPU-only likely)")
        cmd = ["lmp", "-in", str(input_file), "-log", str(log_file)]
    
    try:
        # Stream output instead of piping everything at once
        process = subprocess.Popen(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            bufsize=1 # Line buffered
        )

        # Print the first few lines to show it started correctly, then dots
        count = 0
        for line in process.stdout:
            if count < 10: # Show startup banner
                print(f"  {line.strip()}")
            elif count % 50 == 0:
                print(".", end="", flush=True)
            count += 1
        
        process.wait()
        print("\n[*] Simulation completed successfully.")

    except subprocess.CalledProcessError as e:
        print(f"\nError: LAMMPS failed with exit code {e.returncode}")
        sys.exit(1)
    except FileNotFoundError:
        print("\nError: 'lmp' executable not found. Ensure LAMMPS is installed and in PATH.")
        sys.exit(1)
    except Exception as e:
        print(f"\nError: An unexpected error occurred: {e}")
        sys.exit(1)

if __name__ == "__main__":
    pass
