"""
Module II & III: Simulation Engine
Generates the LAMMPS input script and executes the simulation.
"""

import subprocess
import sys
from pathlib import Path

def generate_input_file(
    data_file: Path,
    input_file: Path,
    output_dump: Path,
    steps: int = 10000,
    temp: float = 300.0,
    damp: float = 20.0,
    epsilon: float = None, # None means use CHONS defaults
    sigma: float = None,   # None means use CHONS defaults
    timestep: float = 1.0,
    bond_params: dict = None,
    angle_params: dict = None
):
    """
    Writes the simulation.in file for LAMMPS with CHONS support and dynamic bonds/angles.
    """
    
    # Standard OPLS-AA Non-bonded parameters (kcal/mol, Angstroms)
    # 1:C, 2:H, 3:O, 4:N, 5:S
    chons_defaults = {
        1: (0.066, 3.50),  # Carbon (Alkane)
        2: (0.030, 2.50),  # Hydrogen
        3: (0.170, 3.12),  # Oxygen (Carbonyl)
        4: (0.170, 3.25),  # Nitrogen
        5: (0.250, 3.55)   # Sulfur
    }
    
    pair_params = {}
    for t in range(1, 6):
        # Use user override if provided, else use real-world default
        final_eps = epsilon if epsilon is not None else chons_defaults[t][0]
        final_sig = sigma if sigma is not None else chons_defaults[t][1]
        pair_params[t] = (final_eps, final_sig)
    
    # Calculate cutoff based on the largest sigma in the system
    max_sigma = max([p[1] for p in pair_params.values()])
    lj_cutoff = max(10.0, 3.0 * max_sigma)

    # Dynamic output frequency: Aim for ~250 data points/frames
    out_freq = max(10, steps // 250)

    content = f"""# LAMMPS Input file generated by Proteus (CHONS Forcefield)

units real
atom_style full
boundary p p p

read_data {data_file.absolute()}

# Force Field
pair_style lj/cut {lj_cutoff:.2f}
pair_modify mix arithmetic
"""
    # Write pair coefficients
    for t, (eps, sig) in pair_params.items():
        content += f"pair_coeff {t} {t} {eps} {sig}\n"

    # Dynamic Bonds
    content += "\nbond_style harmonic\n"
    if bond_params:
        for b_type, (k, r0) in bond_params.items():
            content += f"bond_coeff {b_type} {k} {r0}\n"
    else:
        # Fallback
        content += "bond_coeff 1 300.0 1.54\n"

    # Dynamic Angles
    content += "\nangle_style harmonic\n"
    if angle_params:
        for a_type, (k, theta0) in angle_params.items():
            content += f"angle_coeff {a_type} {k} {theta0}\n"
    else:
        # Fallback
        content += "angle_coeff 1 60.0 109.5\n"

    content += f"""
neighbor 2.0 bin
neigh_modify delay 0 every 1 check yes

# 1-4 interactions are typically scaled in molecular force fields
special_bonds lj 0.0 0.0 0.5 

# Group definitions
group all_atoms type 1 2 3 4 5

# Simulation Protocol
minimize 1.0e-4 1.0e-6 100 1000
reset_timestep 0

timestep {timestep}

# 2. Equilibration / Dynamics
fix 1 all langevin {temp} {temp} {damp} 48279
fix 2 all nve

# Output
dump 1 all custom {out_freq} {output_dump.absolute()} id mol type x y z
compute rg all gyration
thermo_style custom step c_rg temp epair
thermo {out_freq}

# Run
run {steps}
"""
    with open(input_file, 'w') as f:
        f.write(content)
    
    print(f"[*] Input file written to {input_file}")
    with open(input_file, 'w') as f:
        f.write(content)
    
    print(f"[*] Input file written to {input_file}")

def run_simulation(input_file: Path, log_file: Path):
    """
    Executes LAMMPS simulation.
    """
    print(f"[*] Starting LAMMPS simulation: {input_file.name}")
    
    # Try to use the local GPU-enabled build if available
    local_lmp = Path(__file__).parent.parent / "external" / "lammps" / "build" / "lmp"
    
    if local_lmp.exists():
        print(f"[*] Found local GPU-enabled LAMMPS binary: {local_lmp}")
        # Enable GPU package with 1 GPU, and use 'gpu' suffix for styles
        cmd = [str(local_lmp), "-sf", "gpu", "-pk", "gpu", "1", "-in", str(input_file), "-log", str(log_file)]
    else:
        print("[!] Local GPU LAMMPS not found, falling back to system 'lmp' (CPU-only likely)")
        cmd = ["lmp", "-in", str(input_file), "-log", str(log_file)]
    
    try:
        # Capture output to suppress huge logs but show errors
        result = subprocess.run(
            cmd, 
            stdout=subprocess.PIPE, 
            stderr=subprocess.PIPE, 
            text=True, 
            check=True
        )
        print("[*] Simulation completed successfully.")
    except subprocess.CalledProcessError as e:
        print(f"Error: LAMMPS failed with exit code {e.returncode}")
        print(e.stderr)
        sys.exit(1)
    except FileNotFoundError:
        print("Error: 'lmp' executable not found. Ensure LAMMPS is installed and in PATH.")
        sys.exit(1)

if __name__ == "__main__":
    pass
